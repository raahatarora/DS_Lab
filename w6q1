#include <iostream>
using namespace std;

class Stack {
private:
    int top;
    int maxSize;
    char* stackArray;

public:
    // Constructor to initialize the stack
    Stack(int size) {
        maxSize = size;
        stackArray = new char[maxSize];
        top = -1; // Indicates an empty stack
    }

    // Destructor to clean up the stack
    ~Stack() {
        delete[] stackArray;
    }

    // Function to check if the stack is empty
    bool isEmpty() {
        return top == -1;
    }

    // Function to push an element onto the stack
    void push(char value) {
        if (top < maxSize - 1) {
            stackArray[++top] = value;
        }
    }

    // Function to pop an element from the stack
    char pop() {
        if (!isEmpty()) {
            return stackArray[top--];
        }
        return '\0'; // Return null character if stack is empty
    }

    // Function to get the top element of the stack
    char peek() {
        if (!isEmpty()) {
            return stackArray[top];
        }
        return '\0'; // Return null character if stack is empty
    }
};

// Function to determine operator precedence
int precedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0; // for non-operators
}

// Function to check if a character is an operator
bool isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/');
}

// Function to convert infix to postfix
void infixToPostfix(const string& infix, string& postfix) {
    Stack stack(infix.length());
    for (char c : infix) {
        if (isalnum(c)) {
            postfix += c; // Add operands directly to output
        } else if (c == '(') {
            stack.push(c);
        } else if (c == ')') {
            while (!stack.isEmpty() && stack.peek() != '(') {
                postfix += stack.pop();
            }
            stack.pop(); // Remove '(' from stack
        } else if (isOperator(c)) {
            while (!stack.isEmpty() && precedence(stack.peek()) >= precedence(c)) {
                postfix += stack.pop();
            }
            stack.push(c);
        }
    }

    // Pop all remaining operators in the stack
    while (!stack.isEmpty()) {
        postfix += stack.pop();
    }
}

// Function to convert infix to prefix
void infixToPrefix(const string& infix, string& prefix) {
    Stack stack(infix.length());
    string reversedInfix;

    // Reverse the infix expression
    for (int i = infix.length() - 1; i >= 0; i--) {
        char c = infix[i];
        if (c == '(') {
            reversedInfix += ')';
        } else if (c == ')') {
            reversedInfix += '(';
        } else {
            reversedInfix += c;
        }
    }

    // Convert the reversed infix to postfix
    string reversedPostfix;
    infixToPostfix(reversedInfix, reversedPostfix);

    // Reverse the postfix to get prefix
    for (int i = reversedPostfix.length() - 1; i >= 0; i--) {
        prefix += reversedPostfix[i];
    }
}

int main() {
    string infix, postfix, prefix;
    cout << "Enter an infix expression: ";
    cin >> infix;

    infixToPostfix(infix, postfix);
    infixToPrefix(infix, prefix);

    cout << "Postfix expression: " << postfix << endl;
    cout << "Prefix expression: " << prefix << endl;

    return 0;
}
